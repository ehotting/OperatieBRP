<?xml version="1.0" encoding="utf-8"?>
<book xmlns="http://docbook.org/ns/docbook">
    <title>TO BRP-expressietaal</title>
    <titleabbrev>Versie 1.0</titleabbrev>

    <chapter>
        <title>Inleiding</title>

        <para>
            De BRP-expressietaal (of verkort expressietaal) is een taal om expressies te beschrijven die gaan over gegevens uit de BasisRegistratie Personen.
            Met de taal kan bijvoorbeeld uitgedrukt worden waar een populatie van personen aan voldoet, zoals “alle vrouwen”, “iedereen ouder dan 18 jaar”
            of “iedereen die woont in gemeente Neerijnen”. Met vergelijkbare expressies kan worden vastgesteld of gegevens van een persoon gewijzigd zijn,
            wat kan leiden tot het sturen van wijzigingen aan afnemers (het zogenaamde ‘attenderen’).
        </para>

        <para>
            Dit document is bedoeld voor ontwikkelaars van de taal. In hoofdlijnen worden de volgende onderwerpen behandeld:

            <itemizedlist>
                <listitem> <para><xref linkend="definitie-expressie"/>; Beschijft wat een expressie precies is en aan welke voorwaarden
                    het moet voldoen.</para> </listitem>
                <listitem> <para><xref linkend="parsen"/>; Beschijft hoe de expressie in String formaat geinterpreteerd en vertaald wordt
                    naar een Java Expressie Object structuur.</para>
                </listitem>
                <listitem> <para><xref linkend="expressie-evaluatie"/>; Beschrijft hoe het evalueren van expressie werkt. Beschrijft de belangrijkste
                    interfaces en implementaties van de Java Expressie Object structuur, de typering van expresssie en hoe vergelijkingen en berekeningen gedaan worden.
                    </para> </listitem>
                <listitem> <para><xref linkend="expressie-foutafhandeling"/>; Beschrijft de foutsituaties die kunnen optreden tijdens het parsen en evalueren.</para> </listitem>
                <listitem> <para><xref linkend="expressie-brp"/>; Beschrijft een aantal specifieke onderwerpen, met betrekking tot gebruik van de expressietaal.</para> </listitem>
            </itemizedlist>
        </para>
    </chapter>


    <chapter xml:id="definitie-expressie">
        <title>Definitie van een expressie</title>

        <para>
            Expressies worden definieerd als een enkele String waarde en moeten voldoen aan een strikte syntax om het te kunnnen interpreteren.
        </para>

        <section>
            <title>Eisen aan de taal</title>
            <para>
                Voor het ontwerp en de implementatie van de expressietaal zijn de volgende eisen meegenomen:
                <itemizedlist>
                    <listitem><para>De expressietaal moet leesbare en begrijpelijke expressies opleveren</para></listitem>
                    <listitem><para>Expressies mogen alleen concrete antwoorden geven als dat op basis van de brongegevens gerechtvaardigd is</para></listitem>
                    <listitem><para>Concepten in de taal moeten zoveel mogelijk Nederlands zijn, met eventuele uitzonderingen voor specifiek (Engelstalig) jargon</para></listitem>
                    <listitem><para>De implementatie moet, waar mogelijk, ontkoppeld zijn van andere onderdelen van de BRP</para></listitem>
                    <listitem><para>De implementatie moet efficiënt zijn. Het bepalen van gegevens van een persoon,
                        bijvoorbeeld, moet 'snel' uitgevoerd kunnen worden.</para></listitem>
                    <listitem><para>Fouten in expressies moeten zo vroeg mogelijk gevonden worden</para></listitem>
                </itemizedlist>
            </para>
        </section>

        <section xml:id="syntax">
            <title>Syntax</title>

            <para>
                De syntax definieert alle mogelijke logische expressies, functies, operatoren en literals. De syntax heeft
                geen inhoudelijke kennis van de gegevensset in de BRP (dwz het kent geen adressen, indicaties, geboortgegevens etc.).
                Deze ontkoppeling heeft als voordeel dat mocht de gegevensset van de BRP uitgebreid worden met nieuwe persoonsgegevens,
                dan hoeft de taal niet aangepast te worden. Het gebruik van persoonsgegevens in de expressietaal is beschreven in
                <xref linkend="persoonsgegevens"/>.
            </para>
            <para>
                De syntax is gedefinieerd in <ulink url="https://nl.wikipedia.org/wiki/Backus-Naur-vorm">Backus-Naur-vorm</ulink>;
                een algemene notatie voor het definieren van de syntax/grammatica van een taal.
                De syntax de BRP Expressietaal is te vinden in het bestand <code>BRPExpressietaal.g4</code>:
            </para>
            <para>
                <programlisting>
                    <xi:include xmlns:xi="http://www.w3.org/2001/XInclude"
                                xml:space="default" href="../main/resources/BRPExpressietaal.g4" parse="text" encoding="UTF-8"/>
                </programlisting>
            </para>

        </section>

    </chapter>

    <chapter xml:id="parsen">
        <title>Parsen van de expressie</title>

        <para>
            Een expressie in String formaat kan niet direct geëvalueerd worden. Er moet een vertaling gemaakt worden
            naar een Java Object. Deze vertaalslag noemen we het parsen en
            deze bestaat uit twee stappen:
            <orderedlist>
                <listitem> <para>Het vertalen van de expressie-String naar een parsetree</para> </listitem>
                <listitem> <para>Het vertalen van de parsetree naar een Java Objectstructuur</para> </listitem>
            </orderedlist>
            De volgende paragrafen gaan hier verder op in.
        </para>
        <section xml:id="parsetree">
            <title>De Parsetree</title>
            <para>
                Allereerst dient er een zogenaamde <ulink url="https://nl.wikipedia.org/wiki/Syntaxisboom">Parsetree</ulink>
                gemaakt te worden van de expressiestring. Dit is een boomstructuur die als tussenstap gebruikt wordt bij het
                vertaling naar een datastructuur.
            </para>
            <para>
                Onderstaand een voorbeeld van de parsetree van de expressie: <programlisting>geslachtsaanduiding = "V" EN geboorte.datum &lt; 2000/0101</programlisting>
                <mediaobject>
                    <imageobject>
                        <imagedata fileref="parsetree.png" width="450">
                        </imagedata>
                    </imageobject>
                </mediaobject>

            </para>
            <section xml:id="parsergeneratie">
                <title>Genereren van de parsercode</title>

                <para>
                    Voor het interpreteren van de syntax (<xref linkend="syntax"/>), het genereren van de parsetree en de vertaling
                    naar een datastructuur wordt gebruik gemaakt van ANTLR (versie 4, www.antlr.org).
                </para>
                <para>
                    ANTLR genereert een Parser, een Lexer en een Visitor welke specifiek zijn voor de BRP. Deze generatie gebeurt
                    development-time en is enkel nodig als de syntax wijzigt (dus niet als er een nieuw element in BRP wordt toegevoegd!).
                </para>
                <para>
                    Het genereren van de parser wordt gedaan door een Maven plugin in de module <code>brp-expressietaal</code>. Om te
                    voorkomen dat generatie standaard gebeurt is profiel <code>genereer-parser</code>) nodig.
                    Het volgende commando genereert de code in de package <code>nl.bzk.brp.domain.expressie.parser.antlr</code>
                    <programlisting>mvn install -Pgenereer-parser</programlisting>
                </para>
            </section>
        </section>

        <section xml:id="expressietree">
            <title>De Expressietree</title>
            <para>
                Het verschil tussen de parsetree en de expressietree, is dat de parsetree een ‘opgeknipt’ stuk tekst is en
                nog geen notie van expressies heeft. In de expressietree is de oorspronkelijke tekst vervangen door ‘echte’ objecten die
                voldoen aan de <code>Expressie</code> interface, zie <xref linkend="expressie-implementatie"/>
            </para>
            <para>
                Uiteindelijk vormt zich een boomstructuur met leaf objecten voor String-, Getal- en Datumwaarden (de literals,
                ofwel de constanten) en parent objecten, de operatoren (expressies die bewerkingen kunnen uitvoeren wat resulteert
                in een nieuwe expressie).
            </para>
        </section>
        <section xml:id="expressie-visitor">
            <title>Parse-visit</title>
            <para>
                Het aflopen van de parsetree door ANTRL resulteert in callbacks in de visitor implementatie <code>ExpressieVisitor</code>.
                In deze <emphasis>visit</emphasis> methode dient aan de hand van de parsecontext een implementatie van <code>Expressie</code> gemaakt te worden.
            </para>
            <para>
                Aan de hand van onderstaande expressie zullen we de werking van de parser-visit ontleden:
                <programlisting>geslachtsaanduiding = "V" EN geboorte.datum &lt; 2000/01/01</programlisting>
            </para>
            <para>
                Dit resulteert in de volgende aanroepen en expressieobjecten.
                <itemizedlist>
                    <listitem>
                        <para>
                            <code>geslachtsaanduiding</code> resulteert in callback:
<programlisting>public Expressie visitElement(
    final BRPExpressietaalParser.ElementContext ctx) {
    //maakt een ElementExpressie welke het attribuut
    //geslachtsaanduiding kan vinden op de persoonslijst
}
</programlisting>
                        </para>
                    </listitem>
                    <listitem>
                        <para>
                            <code>"V"</code> resulteert in callback:
<programlisting>public Expressie visitStringLiteral(
        final BRPExpressietaalParser.StringLiteralContext ctx
    ) {
        //maakt een StringLiteral expressie
}
</programlisting>
                        </para>
                    </listitem>
                    <listitem>
                        <para>
                            <code>=</code> resulteert in de callback:
<programlisting>public Expressie visitEqualityExpression(
    final BRPExpressietaalParser.EqualityExpressionContext ctx) {
    //maakt een VergelijkingOperator expressie voor de
    //ElementExpressie(geslachtsaanduiding)
    //en de StringLiteral("V").
}
</programlisting>
                        </para>
                    </listitem>
                    <listitem>
                        <para>
                            <code>geboorte.datum</code> resulteert in callback:
<programlisting>public Expressie visitElement(
    final BRPExpressietaalParser.ElementContext ctx) {
    //maakt een ElementExpressie die geboorte.datum kan vinden
    //op de persoonslijst
}
</programlisting>
                        </para>
                    </listitem>
                    <listitem>
                        <para>
                            <code>2000/01/01</code> resulteert in de callback:
<programlisting>public Expressie visitDateLiteral(
    final BRPExpressietaalParser.DateLiteralContext ctx) {
    //maakt een DatumLiteral expressie
}
</programlisting>
                        </para>
                    </listitem>
                    <listitem>
                        <para>
                            <code>&lt;</code> resulteert in de callback:
<programlisting>public Expressie visitRelationalExpression(
    final BRPExpressietaalParser.RelationalExpressionContext ctx) {
    //maakt een VergelijkingOperator expressie voor het vergelijken van
    //het resultaat van de ElementExpressie(geboorte.datum)
    //en de DatumLiteral(2000/01/01)
}
</programlisting>
                        </para>
                    </listitem>
                    <listitem>
                        <para><code>EN</code> resulteert in de callback:</para>
<programlisting>public Expressie visitBooleanExp(
    final BRPExpressietaalParser.BooleanExpContext ctx) {
    //maakt een EnOperator expressie voor de VergelijkingOperator(=)
    //en de VergelijkingOperator(&lt;)
}
</programlisting>
                    </listitem>
                </itemizedlist>
            </para>
        </section>

        <section>
            <title>De Parsecontext</title>
            <para>
                Bij het parsen van een expressie wordt gebruik gemaakt van een <code>Context</code> object. Deze context is nodig
                voor het kunnen parsen van expressies die afhankelijk zijn van variabelen die pas evaluatie-tijd beschikbaar komen.
                Om de expressie dan toch te kunnen parsen dient op de context een variabele gedeclareerd te worden tezamen met het <code>ExpressieType</code>
                (Zie <xref linkend="expressie-typen"/> ).
            </para>
            <para>
                Expressies in de BRP zijn grofwel in te delen in twee smaken, 'normale' en attendering expressies. Voor beide expressies geldt
                dat ze afhankelijk zijn van persoonsgegevens. Naar deze persoonsgegevens wordt verwezen middels variabelen welke door de expressietaal-code
                reeds correct gedefinieerd zijn.
            </para>
            <para>
                Voor 'normale' expressies bestaat er daarom de <code>persoon</code> variabele. Deze variabele gehoeft niet expliciet in de
                expressie gebruikt te worden als een persoonsgegeven wordt aangewezen, maar het mag wel. Indien er geen variabele
                opgegeven is valt het systeem terug op deze impliciete variabele. Bijvoorbeeld, de expressie <emphasis>persoon.BSN</emphasis> definieert
                de variabele expliciet, waarbij de expressie <emphasis>BSN</emphasis> dat niet doet.
            </para>

            <para>
                Voor attenderingexpressies als <emphasis>GEWIJZIGD(oud, nieuw)</emphasis> wordt gebruik gemaakt van twee persoonslijsten,
                De variabele <code>oud</code> wijst naar het <emphasis>oude</emphasis> persoonsbeeld en de variabele <code>nieuw</code> wijst naar
                het nieuwe persoonsbeeld. In tegenstelling tot de <code>persoon</code> variabele dienen deze variabelen altijd expliciet
                gebruikt te worden.
                De variabelen worden automatisch gedefinieerd in de <code>parse</code> en <code>evalueerAttenderingsCriterium</code> methoden in <code>BRPExpressies</code>
                Zie <xref linkend="expressie-api"/>
            </para>
        </section>

    </chapter>

    <chapter xml:id="expressie-evaluatie">
        <title>Evalueren van een expressie</title>

        <para>
            Het evalueren van de expressie wordt simpelweg gedaan door het aanroepen van de <code>evalueer</code>
            methode op het <code>Expressie</code> object. Evaluatie is recursief, onderliggende expressies worden eerst geevalueerd.
            Hierbij wordt ook een <code>Context</code> object doorgegeven welke
            gebruikt wordt voor het resolven van variabelen, of het definieren van een tijdelijke scope.
        </para>
        <para>
            <mediaobject>
                <imageobject>
                    <imagedata fileref="expressie_evaluatie.png" width="400"> </imagedata>
                </imageobject>
            </mediaobject>
        </para>
        <para>
            De evaluatievolgorde voor bovenstaand voorbeeld is:
            <orderedlist>
                <listitem> <para>client evalueert EN</para> </listitem>
                <listitem> <para>EN evalueert =</para> </listitem>
                <listitem> <para>= evalueert geslachtsaanduiding; resultaat is een <code>LijstExpressie</code></para> </listitem>
                <listitem> <para>= evalueert "V"; resultaat is een <code>StringLiteral</code></para> </listitem>
                <listitem> <para>= evaluatie klaar; resultaat is <code>BooleanLiteral</code></para> </listitem>
                <listitem> <para>EN evalueert &lt;</para> </listitem>
                <listitem> <para>&lt; evalueert geboorte.datum; resultaat is een <code>LijstExpressie</code></para> </listitem>
                <listitem> <para>&lt; evalueert 2000/01/01; resultaat is een <code>DatumLiteral</code></para> </listitem>
                <listitem> <para>&lt; evaluatie klaar; resultaat is een <code>BooleanLiteral</code></para> </listitem>
                <listitem> <para>EN evaluatie klaar; resultaat is <code>BooleanLiteral</code></para> </listitem>
            </orderedlist>
        </para>

        <section xml:id="context">
            <title>Context</title>

            <para>
                De evaluatie van een expressie vindt plaats in een bepaalde context; gedefinieerde symbolische namen met hun waarde.
                Een aantal variabelen worden gedefinieerd door de expressietaal zelf; de variabelen <emphasis>persoon, oud, nieuw</emphasis>.
                Andere variabelen worden gedefinieerd door functies of closures.
            </para>

            <para>
                Een context kan ook een andere context omvatten, er vormt zich dan een context hierarchie.
                Het maken van een nieuwe context resulteert in een tijdelijke scope waarin child-expressies evalueren. Bijvoorbeeld, de <code>MAPFunctie</code>
                itereert over de waarden van een lijst en voert hier vervolgens een expressie op uit. Om dit te doen wordt een nieuwe context
                gemaakt, waarbij een nieuwe contextvariabele de actuele iteratiewaarde bevat. Na evaluatie van de functie wordt de context tezamen met
                de geintroduceerde variabelen weggegooid.
            </para>
            <para>
                Als een identifier wordt opgezocht in een context, kijkt de context eerst in
                de eigen collectie identifiers; indien de naam daar niet gevonden wordt, wordt de vraag doorgespeeld aan de omliggende context enzovoort.
                <mediaobject>
                    <imageobject>
                        <imagedata fileref="context.png" width="200">
                        </imagedata>
                    </imageobject>
                </mediaobject>
            </para>
            <para>
                In het bovenstaande voorbeeld zijn drie contexten aan elkaar gekoppeld. Een verwijzing naar x in een expressie levert 10,
                een verwijzing naar y levert “Gandalf” en een verwijzing z levert 1970/JAN/01.
            </para>
            <para>
                Een expressie waarbij de bovenstaande (hypothetische) situatie kan ontstaan, is:
                (((x WAARBIJ x = 10, y = “Gandalf”) WAARBIJ z=1970/JAN/01) WAARBIJ x = 20). Deze expressie levert als resultaat dus 10.
            </para>

        </section>
        <section xml:id="expressie-implementatie">
            <title>Expressie implementatie</title>

            <para>
                Het resultaat van het parse proces is één enkele expressie Object dat conformeert aan de interface
                <code>nl.bzk.brp.domain.expressie.Expressie</code>. Dit hoofstuk behandelt de belangrijkste implementaties.
                <mediaobject>
                    <imageobject>
                        <imagedata fileref="expressietaal_expressie_interface.png" width="450" >
                        </imagedata>
                    </imageobject>
                </mediaobject>
            </para>


            <section>
                <title>Expressie superinterface</title>

                <para>
                    De interface <code>Expressie</code> is de superinterface voor alle expressies.
                    De belangrijkste kenmerken van expressies zijn dat ze een <code>ExpressieType</code> hebben
                    en geëvalueerd kunnen worden. Implementaties zijn herbruikbaar en threadsafe.
                </para>
                <para>
                    De methode <emphasis>Expressie evalueer(Context context);</emphasis>
                    Evalueert de expressie gegeven een context van identifiers. In de regel wordt de expressie berekend voor een
                    bepaald BRP-object. Dit object is via de context beschikbaar; standaard is dat "persoon", een identifier die
                    verwijst naar de persoon waarvoor de expressie geëvalueerd wordt).
                </para>
                <para>
                    De methode <emphasis>ExpressieType getType(Context context);</emphasis>
                    Geeft het type van de Expressie, zo precies mogelijk. Voor de meeste expressies is er een
                    intrinsiek type bekend (boolean operator, optellen, aftrekken, enzovoort), maar voor symbolische waarden
                    (variabelen en attributen) is dat niet altijd zo. In dat laatste geval is het type UNKNOWN. In die laatste
                    gevallen kan het type pas definitief bepaald worden tijdens evaluatie. Zie ook (<xref linkend="expressie-typen"/>)
                </para>
            </section>

            <section>
                <title>Literals</title>

                <para>
                    De <code>nl.bzk.brp.domain.expressie.Literal</code> interface is de superinterface
                    voor alle constante waarden in een expressie. Dit zijn de leaf-objecten in de expressietree.
                </para>
                <para>
                    Met constant wordt bedoelt dat het parsetijd al vast staat wat de waarde is van de expressie. Het evalueren van
                    de expressie geeft een referentie naar zichzelf:
                    <programlisting>@Override
                        default Expressie evalueer(final Context context) {
                        // De evaluatie van een constante is - per definitie - gelijk aan zichzelf.
                        return this;
                        }
                    </programlisting>
                </para>

                <para>
                    De <code>Literal</code> implementaties staan in <code>nl.bzk.brp.domain.expressie.literal</code>:
                    <itemizedlist>
                        <listitem> <para>BooleanLiteral; bevat de waarden <code>true</code> of <code>false</code></para> </listitem>
                        <listitem> <para>DateLiteral; bevat datum (deels onbekend) bijv, 2010/04/01 of 2012/00/00</para> </listitem>
                        <listitem> <para>DateTimeLiteral; bevat een volledigbekende datum met tijd 2010/04/01/11/30/30</para> </listitem>
                        <listitem> <para>GetalLiteral bevat een nummer van het type <code>Long</code></para> </listitem>
                        <listitem> <para>StringLiteral bevat een String waarde</para> </listitem>
                        <listitem> <para>ElementnaamLiteral; betreft een element notatie, bijvoorbeeld [Persoon.Geboorte.GeboorteDatum]</para> </listitem>
                        <listitem> <para>MetaObjectLiteral; bevat een MetaObject</para> </listitem>
                        <listitem> <para>MetaGroepLiteral; bevat een MetaGroep</para> </listitem>
                        <listitem> <para>MetaRecordLiteral; bevat een MetaRecord</para> </listitem>
                        <listitem> <para>ActieLiteral; bevat een Actie</para> </listitem>
                        <listitem> <para>PeriodeLiteral; bevat een periode aanduiding, wat handig is bij het rekenen met datums</para> </listitem>
                        <listitem> <para>NullLiteral; representatie van iets dat niet bestaat, bijvoorbeeld een ontbrekend attribuut op de persoonslijst</para> </listitem>
                    </itemizedlist>
                </para>
            </section>

            <section>
                <title>Operatoren</title>

                <para>
                    De <code>Operator</code> is de interface van alle operator expressies en heeft als supertype <code>NonLiteralExpressie</code>.
                    Operator-expressies doen een bewerking op één of meerdere expressies wat resulteert in een nieuwe expressie.
                    Bijvoorbeeld, 1 + 1 evalueert tot 2 en 1 &lt; 2 evalueert tot true. De operatoren zijn
                    zelf weer onderverdeeld in twee categorien, de unaire operatoren en de binaire operatoren.
                </para>

                <section>
                    <title>Unaire operator</title>
                    <para>
                        Unaire operatoren werken met één operand en hebben als supertype
                        de abstractie <code>nl.bzk.brp.domain.expressie.operator.AbstractUnaireOperator</code>.
                    </para>
                    <para>
                        Er bestaan twee implementaties:
                        <itemizedlist>
                            <listitem>
                                <para>LogischeInverseOperator; voor het inverteren van een <code>boolean</code> expressie, bijvoorbeeld !true</para>
                            </listitem>
                            <listitem>
                                <para>NumeriekeInverseOperator; voor het inverteren van de signed bit van een getal</para>
                            </listitem>
                        </itemizedlist>
                    </para>
                </section>

                <section>
                    <title>Binaire operator</title>
                    <para>
                        Binaire operatoren werken met met twee operands en hebben als supertype de
                        abstractie <code>nl.bzk.brp.domain.expressie.operator.AbstractBinaireOperator</code>.
                    </para>
                    <para>
                        Er bestaan meerdere implementaties:
                        <itemizedlist>
                            <listitem>
                                <para>Rekenoperator; voor het uitvoeren van berekeningen als plus, minus. Maakt gebruikt van de speciale berekenfuncties, zoals
                                    beschreven in: <xref linkend="expressie-berekeningen"/></para>
                            </listitem>
                            <listitem>
                                <para>VergelijkingOperator; voor het uitvoeren van een vergelijkingen; gelijk, ongelijk, klein,
                                    kleinergelijk, groter, grotergelijk, wildcard-gelijk. Maakt gebruikt van de speciale vergelijkfunctie, zoals
                                    beschreven in: <xref linkend="expressie-vergelijkingen"/>
                                </para>
                            </listitem>
                            <listitem><para>EnOperator; voor het uitvoeren van een logische EN</para></listitem>
                            <listitem><para>OfOperator; voor het uitvoeren van een logische OF</para></listitem>
                            <listitem>
                                <para>
                                    EAOperator; voor vergelijkingen met lijsten, bijvoorbeeld alle waarden in de lijst zijn
                                    kleiner dan X, of er is een waarde in de lijst groter dan Y. Maakt gebruikt van de speciale vergelijkfunctie, zoals
                                    beschreven in: <xref linkend="expressie-vergelijkingen"/>
                                </para>
                            </listitem>
                            <listitem>
                                <para>EAINOperator; voor gelijk-vergelijkingen met lijsten,
                                    bijvoorbeeld elke waarde uit de linkercollectie moet voorkomen in de rechtercollectie,
                                    of er moet minimaal één waarde uit de linkercollectie moet voorkomen in de rechtercollectie.
                                    Maakt gebruikt van de speciale vergelijkfunctie, zoals
                                    beschreven in: <xref linkend="expressie-vergelijkingen"/>
                                </para>
                            </listitem>
                            <listitem>
                                <para>EAINWildcardOperator; voor wildcard-vergelijkingen met lijsten,
                                    vb voor elke collectiewaarde van het linkeroperand moet er een match zijn met een wildcard-expressie uit het rechteroperand.
                                    vb voor minimaal één collectiewaarde van het linkeroperand moet er een match zijn met een wildcard-expressie uit het rechteroperand.
                                    Maakt gebruikt van de speciale vergelijkfunctie, zoals
                                    beschreven in: <xref linkend="expressie-vergelijkingen"/>
                                </para>
                            </listitem>
                        </itemizedlist>
                    </para>
                </section>

            </section>

            <section>
                <title>Functies</title>
                <para>
                    De <code>FunctieExpressie</code> maakt het mogelijk om functie constructies te gebruiken in de expressietaal.
                    De namen van de functies zijn hard vastgelegd in de syntax, het aantal argumenten en het type van de argumenten
                    echter niet. Bij het parsen dient deze controle alsnog gedaan te worden middels een
                    <code>Signatuur</code> object, welke gebonden is aan de functie.
                </para>
                <para>
                    Het niet vastleggen van het aantal argumenten en in minder mate de typering van de argumenten in de
                    expressietaalsyntax is een designkeuze geweest met als rationale de syntax-definitite simpel te houden.
                </para>
                <para>
                    De <code>FunctieExpressie</code> maakt gebruikt van de <code>FunctieFactory</code> voor
                    het vinden van <code>Functie</code> implementaties. Dit gebeurt parsetijd bij het instantieren
                    van de <code>FunctieExpressie</code>. De <code>FunctieFactory</code> scant eenmalig (in de package <code>nl.bzk.brp.domain.expressie.functie.</code>) naar
                    implementaties van <code>Functie</code> met <code>@FunctieKeyword</code> annotatie.
                    Van belang is hierbij dat de naam van de annotatie bv <emphasis>VANDAAG</emphasis>
                    in @FunctieKeyword("VANDAAG") exact overeenkomt met de naam van de functie in de syntaxdefinitie.
                    Alleen dan kan de functie correct geresolved door de <code>FunctieFactory</code>.
                    <mediaobject>
                        <imageobject>
                            <imagedata fileref="expressietaal_functie_resolve.png" width="450" >
                            </imagedata>
                        </imageobject>
                    </mediaobject>
                </para>
                <para>
                    Er bestaan vele functies in de expressietaal die allemaal worden uitgevoerd door de <code>FunctieExpressie</code>.
                    Voor het echte werk delegeert de <code>FunctieExpressie</code> naar <code>Functie</code> implementaties.
                    Deze implementaties zijn te vinden in de package <code>nl.bzk.brp.domain.expressie.functie</code>.
                </para>

                <para>
                    De <code>nl.bzk.brp.domain.expressie.functie.Functie</code> is de superinterface van alle functies.
                    <mediaobject>
                        <imageobject>
                            <imagedata fileref="expressietaal_functie.png" width="300" >
                            </imagedata>
                        </imageobject>
                    </mediaobject>
                </para>

            </section>

            <section>
                <title>Variabelen</title>
                <para>
                    De <code>VariabeleExpressie</code> wordt gedefinieerd met een identifier. Deze identifier is een verwijzing naar een
                    waarde (de variabele) die aanwezig is op de evaluatiecontext. Het evalueren van de <code>VariabeleExpressie</code>
                    maakt het mogelijk om waarden uit de evaluatiecontext te halen en terug te geven. Het Java type van deze waarden is ook
                    altijd een <code>Expressie.</code>
                </para>
            </section>

            <section xml:id="persoonsgegevens">
                <title>Persoonsgegevens</title>
                <para>
                    De ElementExpressie is in staat gegevens te selecteren van het <code>MetaModel</code>
                    van Persoonslijst en de gevonden waarden te retourneren
                    als een LijstExpressie. Deze lijst kan leeg zijn of gevuld, maar bevat nooit NULL waarden indien persoonsgegevens niet
                    bestaan.
                </para>
                <para>
                    ElementExpressies op attribuut, groep, object leveren leveren respectievelijk
                    een <code>LijstExpressie</code> met <code>MetaAttribuut></code> <emphasis>waarden</emphasis>,
                    <code>MetaGroepLiterals></code> en <code>MetaObjectLiterals</code> op.
                </para>
                <para>
                    In de syntax wordt een persoonsgegevens geefinieerd als de reguliere expressie
                    (zie <emphasis>element_path</emphasis> in <xref linkend="syntax"/>.
                    Een element_path is herhaling van een door een punt (.) gescheiden reeks tekens.
                    De syntax controleert alleen op het patroon. Deze soepelheid van de taal houdt de syntax simpel en de taal makkelijker onderhoudbaar.
                    Een tekenreeks dat aan het patroon voldoet hoeft
                    dus niet per sé een geldig aanwijsbaar persoonsgegevens te zijn. Hier zijn extra parse-time controles voor nodig.
                </para>
                <section>
                    <title>Resolving</title>
                    <para>
                        De <emphasis>driver</emphasis> voor persoonsgegevens-expressies is de <emphasis>Element</emphasis> tabel,
                        en dan specifiek de kolommen, naam, alias en identxsd. De waarden in deze kolommen zijn de basis
                        voor expressies op persoonsgegevens.
                    </para>
                    <para>
                        Voor alle mogelijke expressies waarmee persoonsgegevens opgevraagd worden bestaat een zogenoemde implementatie
                        van de <code>nl.bzk.brp.domain.expressie.element.Resolver</code> interface. De <code>nl.bzk.brp.domain.expressie.element.ResolverMap</code>
                        is bekend met alle resolvers en wordt gebruikt door <code>ElementExpressie</code> om de persoonsgegevens daarwerkelijk te vinden.
                    </para>
                    <para>
                        Onderstaand een aantal voorbeelden van expressies op persoonsgegevens, hoe deze samengesteld zijn en hoe ze geresolved worden.
                        <itemizedlist>
                            <listitem>
                                <para><emphasis>Persoon.Identificatienummers.Burgerservicenummer</emphasis>; deze elementnaam is direct te gebruiken
                                    als expressie om een attribuut te vinden op de PL.
                                </para>
                                <para><emphasis>x.Naamgebruik.Voorvoegsel</emphasis>; hierbij is x een variabele, en Naamgebruik.Voorvoegsel een samenvoeging
                                    van groep alias en attribuut alias. Tijdens evaluatie moet eerst x geresolved worden tot een MetaObject. Binnen de context
                                    van dat object wordt vervolgens gezocht naar het attribuut met alias Voorvoegsel binnen de groep met alias Naamgebruik.
                                </para>
                                <para><emphasis>x.burgerservicenummer</emphasis>; hierbij is x een variabele, en burgerservicenummer attribuut alias.
                                    Tijdens evaluatie moet eerst x geresolved worden tot een MetaGroep. Binnen de context
                                    van dat object wordt vervolgens gezocht naar het attribuut met alias Voorvoegsel binnen de groep met alias Naamgebruik.
                                </para>
                                <para><emphasis>Persoon.Identificatienummers</emphasis>; deze elementnaam is direct te gebruiken
                                    als expressie om een groep te vinden op de PL.
                                </para>
                                <para><emphasis>geboorte</emphasis>; dit is de alias van de Persoon.Geboorte groep. Er is geen variabele gedefinieerd,
                                    dus er zal gezocht worden naar alle geboorte groepen binnen Persoon.
                                </para>
                                <para><emphasis>Persoon.Adres</emphasis>; deze elementnaam is direct te gebruiken
                                    als expressie om een object te vinden op de PL.
                                </para>
                                <para><emphasis>Nationaliteiten</emphasis>; deze naamalias van het objecttype Persoon.Nationaliteit is direct te gebruiken
                                    alle MetaObjecten te vinden van type Persoon.Nationaliteit.
                                </para>
                            </listitem>
                        </itemizedlist>
                    </para>
                </section>

            </section>
        </section>
        <section xml:id="expressie-typen">
            <title>ExpressieType</title>
            <para>
                Elke expressie heeft een type (net als bijvoorbeeld in Java). Het type van een expressie is gedefinieerd als het
                type van het resultaat als de expressie succesvol geëvalueerd zou worden.
                Voorbeelden:
                <itemizedlist>
                    <listitem> <para>Het type van de expressie “10” is GETAL.</para> </listitem>
                    <listitem> <para>Het type van de expressie “WAAR” is BOOLEAN.</para> </listitem>
                    <listitem> <para>Het type van de expressie “1 + 2” is GETAL (als de expressie geëvalueerd zou worden, zou dat leiden tot een GETAL).</para> </listitem>
                    <listitem> <para>Het type van de expressie “1 &lt; 2” is BOOLEAN.</para> </listitem>
                    <listitem> <para>Het type van de expressie “VANDAAG()” is DATUM.</para> </listitem>
                    <listitem> <para>Het type van de expressie “geboorte.datum” is LIJST.</para> </listitem>
                </itemizedlist>
            </para>

            <section>
                <title>Ordinal basistypes</title>
                <para>
                    De expressietaal kent drie ordinal basistypes.
                    Dit zijn types die een grootheid aanduiden; elementen van deze types zijn geordend en kunnen onderling vergeleken worden met groter dan en kleiner dan:
                    <itemizedlist>
                        <listitem> <para>GETAL: gehele getallen, zowel positief als negatief;</para> </listitem>
                        <listitem> <para>DATUM: datum, mogelijk met onbekende delen;</para> </listitem>
                        <listitem> <para>DATUMTIJD: datum met tijd, volledig bekend;</para> </listitem>
                        <listitem> <para>PERIODE: tijdsperiode.</para> </listitem>
                    </itemizedlist>
                </para>
            </section>

            <section>
                <title>Niet-ordinal basistypes</title>
                <para>
                    De expressietaal kent drie basistypes die niet ordinal zijn:

                    <itemizedlist>
                        <listitem> <para>STRING: tekenreeksen;</para> </listitem>
                        <listitem> <para>BOOLEAN: logische waarden WAAR en ONWAAR;</para> </listitem>
                        <listitem> <para>LIJST: lijsten van expressies. Ontwerpkeuze
                            Om het typesysteem van de expressietaal eenvoudig te houden, zijn lijsten in principe ongetypeerd.
                            De expressietaal kent geen onderscheid tussen lijst van getallen en een lijst van strings.
                            In sommige gevallen echter is het wel zinvol om iets over de typering van elementen te weten;
                            daarvoor zijn methoden in de interface Expressie gedefinieerd.</para> </listitem>
                    </itemizedlist>
                </para>
            </section>


            <section>
                <title>Speciale types</title>
                <para>
                    De expressietaal kent een aantal speciale types. Deze worden gebruikt voor bijzondere gevallen. Ze zijn niet ordinal.
                    <itemizedlist>
                        <listitem> <para>NULL: type van waarden die niet bepaald kunnen worden</para> </listitem>
                        <listitem> <para>ONBEKEND_TYPE: type van waarden waarvan het type (nog) niet bepaald kan worden;</para> </listitem>
                        <listitem> <para>ELEMENT: de expressie is een notatie voor een element op de persoonslijst. De <code>ElementnaamLiteral</code>
                        en de <code>GEWIJZIGD</code> functie maken hier gebruik van om een element aan te wijzen, zonder dat deze direct geëvalueerd wordt.</para> </listitem>
                        <listitem> <para>BRP_METARECORD: Voor <code>MetaRecordLiteral</code>s om records van persoonsgegevens door te geven.</para> </listitem>
                        <listitem> <para>BRP_METAGROEP: Voor <code>MetaGroepLiteral</code>s om groepen van persoonsgegevens door te geven.</para> </listitem>
                        <listitem> <para>BRP_METAOBJECT: Voor <code>MetaObjectLiteral</code>s om objecten van persoonsgegevens door te geven.</para> </listitem>
                        <listitem> <para>BRP_ACTIE: Voor <code>ActieLiteral</code>s om verantwoording van persoonsgegevens door te geven.</para>
                        </listitem>
                    </itemizedlist>
                </para>
            </section>
        </section>

        <section xml:id="expressie-vergelijkingen">
            <title>Vergelijkingen</title>

            <para>
                Er is een designkeuze gemaakt om de vergelijkingen <emphasis>kleiner, kleinergelijk, groter, grotergelijk, gelijk, ongelijk en wildcardgelijk</emphasis>
                voor alle datatypen <emphasis>getal, String, boolean, null, datum, datumtijd, lijst </emphasis>los te trekken van de operatoren en van de objecten
                die met elkaar vergeleken worden.
            </para>
            <para>
                Bijvoorbeeld, een <code>GetalLiteral</code> weet niet hoe deze vergeleken wordt met een andere
                <code>GetalLiteral</code> en de <code>VergelijkingOperator</code> weet niet hoe het twee getallen met elkaar moet vergelijken.
            </para>
            <para>
                Voor het uitvoeren van een vergelijkingen moet er gebruik gemaakt worden van de
                speciale <code>Vergelijking</code> interface, het supertype voor alle vergelijkingen.
                Een <code>Vergelijking</code> is een <code>BiFunctie</code> met als parameters en return type een <code>Expressie</code>.
                <mediaobject>
                    <imageobject>
                        <imagedata fileref="expressietaal_vergelijker.png" width="450" >
                        </imagedata>
                    </imageobject>
                </mediaobject>

                Implementaties van <code>Vergelijking</code> kunnen enkel verkregen worden via de <code>VergelijkerFactory</code>.
                Deze factory scant eenmalig naar implementaties in de package <code>nl.bzk.brp.domain.expressie.vergelijker</code>.
                Voorwaarde is dat implementaties geannoteerd zijn met de <code>@Component</code> en de <code>VergelijkerConfig</code> annotaties.
                De <code>VergelijkerConfig</code> annotatie geef aan welke <code>ExpressieType</code> operands hebben en welk type vergelijking
                ondersteund wordt.
            </para>
            <para>
                Om een <code>Vergelijking</code> op te halen met de <code>VergelijkerFactory</code>
                dient opgegeven te worden welk type vergelijking gedaan moet worden en wat de type operands zijn.
                (combinatie <code>ExpressieType</code> en <code>OperatorType</code>).
            </para>
            <para>

                Onderstaand een voorbeeld waar een boolean gelijk vergelijking gedaan wordt:
                <programlisting>@Component
@Vergelijking(operator = OperatorType.GELIJK, typeSupport = ExpressieType.BOOLEAN)
final class BooleanGelijkVergelijker implements Vergelijker&lt;BooleanLiteral, BooleanLiteral> {

    public Expressie apply(final BooleanLiteral l, final BooleanLiteral r) {
        return BooleanLiteral.valueOf(l.equals(r));
    }
}</programlisting></para>
        </section>

        <section xml:id="expressie-berekeningen">
            <title>Berekeningen</title>
            <para>
                Analoog aan vergelijkingen zijn berekeningen als plus, min, losgetrokken van de operatoren en van de objecten waarmee gerekend wordt.
                Voor het uitvoeren van een berekening moet er gebruik gemaakt worden van de
                speciale <code>Berekening</code> interface, het supertype voor alle berekeningen.
                <mediaobject>
                    <imageobject>
                        <imagedata fileref="expressietaal_berekening.png" width="450" >
                        </imagedata>
                    </imageobject>
                </mediaobject>
            </para>
            <para>
                Een <code>Berekening</code> is een <code>BiFunctie</code> met als parameter en return type <code>Expressie</code>.
                De <code>BerekeningFactory</code> scant eenmalig naar implementaties in de package <code>nl.bzk.brp.domain.expressie.berekening</code>,
                middels de <code>@Component</code> annotatie en de <code>BerekeningConfig</code> annotatie.
                De <code>BerekeningConfig</code> annotatie geef aan welke <code>ExpressieType</code> operands hebben en welke rekenoperator
                ondersteund wordt.
            </para>
            <para>
                Operatoren of functies welke een berekening willen doen moeten de <code>BerekeningFactory</code> vragen om een
                instantie van <code>Berekening</code> welke in staat is een bepaald type berekening te doen
                (combinatie <code>ExpressieType</code> en <code>OperatorType</code>). De <code>BerekeningFactory</code> is verantwoordelijk
                voor het zoeken van de correcte <code>Berekening</code> implementaties.
            </para>
            <para>
                Onderstaand een voorbeeld waar een getallen opgeteld worden:
                <programlisting>@Component
@BerekeningConfig(operator = OperatorType.PLUS,
                    typeLinks = ExpressieType.GETAL,
                    typeRechts = ExpressieType.GETAL)
final class GetalPlusGetal implements Berekening&lt;GetalLiteral, GetalLiteral> {

    @Override
    public Expressie apply(final GetalLiteral getalLiteral,
                            final GetalLiteral getalLiteral2) {
        return new GetalLiteral(getalLiteral.alsInteger()
            + getalLiteral2.alsInteger());
    }
}</programlisting>
            </para>
        </section>
    </chapter>

    <chapter xml:id="expressie-foutafhandeling">
        <title>Foutafhandeling</title>

        <para>
            Fouten in expressies kunnen op verschillende momenten gedetecteerd worden en effect hebben.
            Veel fouten worden tijdens het vertalen van een expressie al gevonden.
            Een expressie <emphasis>“persoon.gboorte.dutum”</emphasis> zal bijvoorbeeld niet geparsed kunnen worden.
        </para>
        <para>
            De expressietaal probeert zo snel mogelijk fouten in de expressies te rapporteren.
            De afweging om fouten vroeg of laat te constateren is vaak gedaan op basis van complexiteit.
            Het is vaak erg lastig is om controles op een vroeg moment te doen, en vele malen makkelijker op een later moment.
            Er zijn drie momenten wanneer er fouten kunnen optreden, syntax, parse-tijd en evaluatietijd.
            In elk van deze gevallen wordt een <code>ExpressieException</code> gegooid met daarin een
            beschrijving van de fout die optreedt.
        </para>

        <para>
            De clientcode (de code welke gebruik maakt van de expressietaal) maakt altijd gebruikt van de klasse
            <code>BRPExpressies</code>. Fouten die optreden bij het parsen of evalueren van de expressies wordt
            altijd vertaald naar de checked <code>ExpressieException</code>. Intern wordt er gebruik gemaakt van
            een aantal runtime excepties (<code>ExpressieParseException</code>), welke naar de 'buitenwereld'
            weer vertaald worden naar een <code>ExpressieException</code>.
        </para>

        <section>
            <title>Syntaxfouten</title>
            <para>
               Syntaxfouten worden gevonden door ANTLR en gerapporteerd middels een errorlistener
                welke gezet wordt op de <code>BRPExpressietaalParser</code> en <code>BRPExpressietaalLexer</code>.
            </para>
            <para>
                De klasse <code>ParserErrorListener</code> is de BRP implementatie van <code>BaseErrorListener</code> en vertaalt de syntaxfout
                naar een <code>ExpressieParseException</code>.
            </para>
        </section>

        <section>
            <title>Parse-tijd fouten</title>
            <para>
                De syntax van de taal is grotendeels weakly typed. Dit heeft tot gevolg dat ANTLR niet kan
                rapporteren over constructies waarbij typen niet overeenkomen met wat verwacht wordt. In deze gevallen
                is het aan de implementatie om dit te constateren en hierover te rapporteren.
            </para>
            <para>
                Een functie-implementatie is bijvoorbeeld afhankelijk van een aantal argumenten van een gegeven type. De syntax
                van de taal zegt helemaal niets over het verwachtte aantal argumenten en het verwachtte type.
                Het controleren van deze argumenten moet daarom zelf gecontroleerd worden (middels een <code>Signatuur</code> check). Hierbij
                wordt gekeken of de argumenten evaluatie-tijd het verwachtte resultaattype gaan teruggeven.
                Bijvoorbeeld: <code>AANTAL(10)</code>; het verwachtte type is LIJST en niet GETAL.
            </para>
            <para>
                De expressie <code>WAAR EN 1</code> geeft de fout "Parsefout: Boolean expressie verwacht".
                EN is een logisch expressie en de linker en rechteroperand moeten van het type BOOLEAN zijn. De rechteroperand
                is een GetalLiteral.
            </para>
        </section>

        <section>
            <title>Evaluatie-tijd fouten</title>
            <para>
                Een aantal controles zijn niet eerder mogelijk dan tijdens evaluatie-tijd. De persoonslijst is bijvoorbeeld
                pas beschikbaar tijdens evaluatie-tijd, controleren mbt het wel / niet aanwezig zijn van attributen, groepen of
                objecten kunnen hier pas gedaan worden.
            </para>
            <para>
                In het kader van robuustheid wordt met onverwachte situaties soepel omgegaan. Dit houdt in dat er géén exceptie
                gegooid wordt maar dat er vaak <code>NULL</code> of <code>ONWAAR</code> geretourneerd wordt in een onverwachte situatie. Er is
                getracht elke operator en functie zo robuust te maken dat het kan omgaan met dit soort situaties.

            </para>
        </section>

    </chapter>


    <chapter xml:id="expressie-brp">
        <title>Expressies in de BRP</title>

        <section xml:id="expressie-api">
            <title>BRPExpressies API</title>

            <para>
                Modules die gebruik willen maken van de expressietaal dienen dat nu te doen middels de
                klasse <code>nl.bzk.brp.domain.expressie.BRPExpressies</code>. Deze klasse biedt een facade voor het parsen en evalueren van expressies.
                Het draagt zorgt voor een correcte vertaling van excepties naar de checked <code>ExpressieException</code>.
            </para>
        </section>

        <section xml:id="performance">
            <title>Performance</title>
            <para>
                Voor elke handeling die verwerkt wordt in mutatielevering worden één of meerdere expressies uitgevoerd per autorisatie. Potentieel
                bevat de database duizenden autorisaties, en moeten er meerdere administratievehandelingen per seconde verwerkt worden.
                Het is daarom erg belangrijk dat het evalueren van expressies goed performt.
            </para>
            <para>
                De grootste performanceoptimalisatie die gedaan is in de BRP is het éénmalig parsen van de expressies tijdens het
                inlezen van de autorisaties. De geparsde expressie wordt vervolgend gecached.
            </para>
            <para>
                Het parsen van expressies is in vergelijking tot het evalueren een relatief duur proces (orde grootte 100 tot 1000 keer duurder).
                De evaluatieperformance hangt sterk af van een aantal factoren; aantal sub-expressies (méér is langzamer), functie gebruik (sommige functies zijn
                minder efficient, bijv hele grote IN clausules), de persoon zelf (bijv oud/nieuw) vergelijkingen op grote persoonslijsten.
                Al met al is de evaluatieperformance nu geen beperkende factor mbt de verwerkingssnelheid in mutatielevering.
                Het is daarom niet verder geoptimaliseerd. Eea is aangetoond met een aantal performance metingen welke te vinden zijn in
                het <emphasis>BRP Benchmark project</emphasis>.
            </para>
        </section>
        
        <section xml:id="verbeterpunten">
            <title>Verbetermogelijkheden</title>
            <para>
                Er zijn altijd verbetermogelijkheden te bedenken, onderstaand een overzicht:
            </para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para>
                            De client-API is niet helemaal strak, evaluatie kan via <code>nl.bzk.brp.domain.expressie.BRPExpressies</code>,
                            of direct op via <code>Expressie</code> object. In het laatste geval moet het Context object zelf goed gevuld worden wat
                            natuurlijk foutgevoelig is. Wellicht is het beter om de context algeheel te verbergen in de client-API en dus ook een
                            andere interface terug te geven aan de client dan de <code>Expressie</code> interface.
                        </para>
                    </listitem>
                    <listitem>
                        <para>De DOT-notatie regex voor persoonsgegevens expressies kan versimpeld worden.</para>
                    </listitem>
                </itemizedlist>
            </para>
        </section>
    </chapter>

</book>
